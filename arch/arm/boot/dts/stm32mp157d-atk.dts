// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
/*
 * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
 * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
 */
/dts-v1/;

#include "stm32mp157.dtsi"
#include "stm32mp15xd.dtsi"
#include "stm32mp15-pinctrl.dtsi"
#include "stm32mp15xxaa-pinctrl.dtsi"
#include "stm32mp157-m4-srm.dtsi"
#include "stm32mp157-m4-srm-pinctrl.dtsi"
#include "stm32mp157d-atk.dtsi"
#include <dt-bindings/usb/pd.h>

/ {
	model = "STMicroelectronics STM32MP157D eval daughter";
	compatible = "st,stm32mp157d-ed1", "st,stm32mp157";

	chosen {
		stdout-path = "serial0:115200n8";
	};

	aliases {
		serial0 = &uart4;
	};

	reserved-memory {
		gpu_reserved: gpu@f6000000 {
			reg = <0xf6000000 0x8000000>;
			no-map;
		};

		optee_memory: optee@fe000000 {
			reg = <0xfe000000 0x02000000>;
			no-map;
		};
	};

	usb_phy_tuning: usb-phy-tuning {
    	st,hs-dc-level = <2>;
    	st,fs-rftime-tuning;
    	st,hs-rftime-reduction;
    	st,hs-current-trim = <15>;
    	st,hs-impedance-trim = <1>;
    	st,squelch-level = <3>;
		st,hs-rx-offset = <2>;
		st,no-lsfs-sc;
	};

	vdd_usb: regulator-vdd-usb {
		compatible = "regulator-fixed";
		regulator-name = "vdd_usb";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		regulator-always-on;
		regulator-boot-on;
	};

	vin: regulator-vin {
		compatible = "regulator-fixed";
		regulator-name = "vin";
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		regulator-always-on;
		regulator-boot-on;
	};
};

&cpu1{
	cpu-supply = <&vddcore>;
};

&gpu {
	contiguous-area = <&gpu_reserved>;
	status = "okay";
};

&optee {
	status = "okay";
};


/* for sdio wifi */
&sdmmc3 {
	pinctrl-names = "default", "opendrain", "sleep";
	pinctrl-0 = <&sdmmc3_b4_pins_a>;
	pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
	pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
	non-removable;
	st,neg-edge;
	bus-width = <4>;
	vmmc-supply = <&v3v3>;
	status = "okay";
	keep-power-in-suspend;
};

/*for usb otg*/
&usbphyc {
	status = "okay";
};

&usbphyc_port1 {
	phy-supply = <&vdd_usb>;
	st,phy-tuning = <&usb_phy_tuning>;
};

&usbotg_hs {
	phys = <&usbphyc_port1 0>;
	phy-names = "usb2-phy";
	usb-role-switch;
	status = "okay";
	port {
		usbotg_hs_ep: endpoint {
			remote-endpoint = <&con_usbotg_hs_ep>;
		};
	};
};

/*for drd driver(stusb1600)*/
&pinctrl {
	usbdrd_pins_b: usbxxx-0 {
		pins {
			pinmux = <STM32_PINMUX('G', 2, ANALOG)>;
			bias-pull-up;
		};
	};
};

&i2c1 {
	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&i2c1_pins_b>;
	pinctrl-1 = <&i2c1_pins_sleep_b>;
	status = "okay";
#if 0
	stusb1600@28 {
	compatible = "st,stusb1600";
		reg = <0x28>;
		interrupts = <2 IRQ_TYPE_EDGE_FALLING>;
		interrupt-parent = <&gpiog>;
		pinctrl-names = "default";
		pinctrl-0 = <&usbdrd_pins_b>;
		status = "okay";
		vdd-supply = <&vin>;

		connector {
			compatible = "usb-c-connector";
			label = "USB-C";
			power-role = "dual";
			power-opmode = "default";

			port {
				con_usbotg_hs_ep: endpoint {
					remote-endpoint = <&usbotg_hs_ep>;
				};
			};
		};
	};
#endif

	fusb302@22 {
		compatible = "fcs,fusb302","fairchild,fusb302";
		reg = <0x22>;
		pinctrl-names = "default";
		pinctrl-0 = <&usbdrd_pins_b>;
		int-n-gpios = <&gpiog 2 GPIO_ACTIVE_HIGH>;
		vbus-5v-gpios = <&gpioz 6 GPIO_ACTIVE_HIGH>;
		status = "okay";

		connector {
			compatible = "usb-c-connector";
			label = "USB-C";
			power-role = "dual";
			power-opmode = "default";

			try-power-role = "sink";
			source-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
			sink-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)
							PDO_VAR(3000, 12000, 3000)
							PDO_PPS_APDO(3000, 11000, 3000)>;
			op-sink-microwatt = <10000000>;
			port {
				con_usbotg_hs_ep: endpoint {
					remote-endpoint = <&usbotg_hs_ep>;
				};
			};
		};
	};

};



